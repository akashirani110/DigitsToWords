SOLUTION EXPLANATION AND REASONS BEHIND THIS APPROACH
1.	Readability and Maintainability: I have created a solution that is using a recursive method, ConvertDigitToWord, which makes the code more modular and easier to understand, as compared to other solutions which can be achieved using long if-else blocks of conditionals.
2.	 Scalability: My approach is highly scalable, allowing for the easy addition of new rules or modifications to handle even larger numbers or more complex numbers. For example, the current approach only evaluates 15-digit numbers which is Trillions but, can be scaled to add higher denominations such as quadrillion. Also, using another approach with standard numerical data types like ‘int’ or ‘long’, would limit the maximum value it could store.
3.	Modularity and Simplicity: By breaking down the number into manageable chunks, my approach simplifies the conversion process. Each chunk can be independently converted to words, which reduces the complexity of the problem. This modular approach makes the code easier to understand, maintain, and debug.
Given that there was no upper limit set to the number, getting a number in a long or int form would have been a long and tedious if-else effort. I saw that the sequences of the words were repetitive, for example, One hundred and twenty thousand, two hundred and forty-five. Hence, I took the number to be a string and split it by “.” first to obtain dollar and cents values. 
Then I broke it into chunks of three starting from right hand side with the last chunk allowed 1- or 2-digit values as well i.e, 12345678 will break as [678,345, 12]. Then I evaluated each one of these chunks and converted them into words using for example first chunk, 678, is first divided by hundred and the dividend (6) is mapped to the word SIX, HUNDRED, AND are added to the list. The remainder being 78 is used to make a recursive call to ConvertDigitToWord function. Number 78 is divided by 10 and 7 is mapped to the word SEVENTY. The remainder 8 is used to make another recursive call and it is mapped to the word EIGHT, giving the final output of the chunk as list of strings i.e., [SIX, HUNDRED, AND, SEVENTY-EIGHT]. This list of strings is converted into a single space separated string i.e., SIX HUNDRED AND SEVENTY-EIGHT.
Similarly, the other chunks are converted to equivalent words as well. Of note, that upto this point, the sequence of the chunks is still in reverse order i.e., [SIX HUNDRED AND SEVENTY-EIGHT, THREE HUNDRED AND FORTY-FIVE, TWELVE]. Now all that needs to be done is add scale suffix to all elements except the first one based on the position of the chunk in the list i.e., [SIX HUNDRED AND SEVENTY-EIGHT, THREE HUNDRED AND FORTY-FIVE THOUSAND, TWELVE MILLION] and reverse this list of strings and join these into one final output. [TWELVE MILLION THREE HUNDRED AND FORTY-FIVE THOUSAND SIX HUNDRED AND SEVENTY-EIGHT].
